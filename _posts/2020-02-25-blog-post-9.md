---
title: 'Blog Post number 4'
date: 2020-02-25
permalink: /posts/2020/02/blog-post-9/
tags:
  - java面试笔记
  - java
  - 刷题
---

一些常见的java面试题

======

- java面向对象的特征有哪些方面

  > 封装：把同一个事物的方法和属性放到一个类中。高内聚，低耦合。防止程序相互依赖而带来的程序变动
  >
  > 抽象：把共性提取出来。把这些归位一个类。
  >
  > 继承：对于已有的父类，想扩充一些新方法，或者改变父类的方法，使之更适合特殊的需要。
  >
  > 多态：一个引用变量到底指向哪个类的实力对象，或者该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才可以。

- 多态实现的条件

  > 继承，重写，向上转型。常量和静态看左边，运行编译看左边，运行看右边。

- volatile

  >轻量级的同步机制
  >
  >保证可见性，不保证原子性，禁止指令重排。
  >
  >JMM：描述了一组规范，这个规范定制了程序中的各个变量的访问方式。
  >
  >JMM关于同步的规定，线程加锁时，必须读取主内存的最新值到自己的工作内存，线程解锁前，必须把共享变量的值刷回主内存。同一个锁。
  >
  >可见性：一个线程对工作内存的数据进行了修改并且写到主内存时，必须通知其他线程。
  >
  >有序性：有时候为了提高程序性能，会进行指令重排，单线程的环境里面确保程序最终执行结果和代码顺序执行的结果一致。指令重排会考虑数据的依赖性。多线程线程时线程交替之行，由于编译器优化重排的存在，两个线程使用的变量能否一致是不确定的。结果无法预测。
  >
  >你在哪些地方用到过volatile?
  >
  >双端检查的单例模式，由于有指令重排，原因在于某一个线程在执行到第一次检测,读取到的instance不为null时,instance的引用对象可能没有完成初始化.

- number++在多线程下是非线程安全的,如何不加synchronized解决?

  > 使用AtomicInteger.



- HashMap结构，是否线程安全，ConcurrentHashMap如何保证线程安全.

为什么hashmap的容量默认一定是2的幂，也就是哈希桶一定是2的n次方。

2的n次方是10000000，2的n次方-1 就是1111111。按位与 才能够 用位运算拿到数组下标还是分布均匀的。如果不是2的n次方，那么-1就会出现 100111，那么不管hash值是多少，最后与他与都是0，也就是总有的桶为空的。

如果你输入的是17会怎么样，会向上调整为2的幂

java 7 默认空间 16。

最多 2-31 次方 ～2-31次方-1个数。如何把这么多数变成 0-n-1。对n取模 不行的，负数取模还是负数，取模很慢。硬件中取模是不停的做除法，会慢。



扩容：resize。rehash 2倍

java7的问题：容易碰到死锁，容易出现环形链表。因为前插法，一个线程3-7 一个线程 7-3

CVE-2011安全问题。

hash碰撞成链表。性能退化

可以通过精心构造的恶意请求引发DoS





java8改进：数组+链表 ->数组+红黑树。为什么超过8会变成红黑树。因为桶里的数据个数。为1的个数，为2的个数，为8的个数非常小了

服从参数为0.5的泊松分布，因为超过8的概率已经很小了。小于10万分之一

扩容时插入顺序改进。扩容有了顺序。要不是和以前相等，要不就是以前的最高位加一。 按位与，

以前是和1111 现在是和11111 按位与。  新索引和旧索引在低位是相同的，在高位要不是0要不是1.

函数方法 foreach。 compute 

Map新的API。merge replace







- Mysql索引innodb怎么实现？为什么是B+tree?

  >Hash虽好，任何增删改查都是O(1)但是搞不定排序和范围查找.找一个范围的话，可能就成O(n)了
  >
  >二叉树。数据量大了Log(n) 还是很大，而且有可能偏斜
  >
  >AVL 数据量越多，树越高，遍历次数越高。IO越多。
  >
  >系统的数据存储是以磁盘块为单位的，block。同一个磁盘块的数据会一次性读出来。若干的块组成一个页16kb。读出去。如果一个页中的所有数据都有助于定位储存位置，那么会大大减少IO的数量。
  >
  >B树，每个节点占一个盘块的空间，不止存储键值，还有两个升序排序的关键字，还有指向子节点的指针，还有数据。数据过大会导致，存储的键值变少，那么数据量大了，树还会变高。 
  >
  >B+树，叶子节点存储所有数据，用一个链表连接起来。除了枝节点存储更多的键值。降低高度。增加了链表，获取所有的节点不再需要中序遍历。















- 

- 

- 

- 

- 

- 

- 

- 

- 说一下cookie和session的区别？

- redis的数据类型？

  





- 三次握手的过程？序号是什么？发送方和接收方如何确定序号？丢包了会怎么样？

  为什么会有三次握手？

  > 客户端A 服务端B
  >
  > A向B发出请求 ACK=0 SYN=1  初始序列号 x
  >
  > B收到A的请求后  生成序列号y，确认号 x+1 ACK=1 SYN=1;
  >
  > A收到B的报文后，生成确认号y+1  序列号为x+1
  >
  > B收到A的确认后，连接建立。
  >
  > 丢包后：如果客户端给服务器发送确认包失败，比如网络抖动，那么服务器有定时器，然后再次发送一次 SYN和ACK数据包。如果过了超时时间，服务器会发送RTS报文，客户端接收到了也会关闭连接。
  >
  > 三次握手的必要性：
  >
  > 为了防止失效的连接到达服务器，打开两个重复的连接。客户端发送的连接请求在网络中滞留，就会隔很长时间收到服务器的确认。客户端有可能再发一个，然后服务器再响应一个。如果没三次握手服务器就打开两个连接，有了三次握手，客户端会忽略服务器之后发送的对滞留连接请求的确认。

- TCP四次挥手？为什么要进行4次挥手?

  >A -> 释放报文，FIN=1。
  >
  >B收到之后发出确认，此时TCP处于半关闭的状态。B能给A发，但是A不能给B发。
  >
  >B确定不要连接，就会发送释放报文。FIN=1。
  >
  >A收到之后，进入TIME-WAIT状态，等2MSL(最大报文存活时间)之后，释放连接。
  >
  >B收到A的确认后释放连接。
  >
  >

  >A 发送给B之后进入 CLOSE-WAIT状态，是为了让B发送完。B用完了就发FIN释放
  >
  >客户端接收到服务端的终端报文后，等2MSL是为了确认最后一个报文能到达。
  >
  >到达后A发送确认。B断开。如果A没有确认，B还会再发。目的是为了下次不会再有旧的连接。
  >
  >



- 数据库两种引擎介绍一下？
- TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？

- 怎么求一个二叉树的深度?
- 排序算法知道哪些，时间复杂度是多少？





- 线程进程——多线程——锁 （非常重要） 

  

​   会涉及： Java中各种关键（volatile等很多）、基础知识（Java中有哪些数据类型、hashmap底层用什么实现） 

​   各种锁，概念/场景/ java中有哪些锁/还包括 数据库的锁 

​   线程池相关 

​   2. jvm内存模型 （重要） 

​   会涉及：（垃圾回收、变量的存储位置、堆栈等） 

​   3.手撕代码（重要） 

​   会涉及：不会有场景的，纯算法(比如 二叉树后序遍历/  单例模式的双重检验) 

​   4.设计模式（重要） 

​   5.知道那些框架 （ssh mvc）（重要） 

​   6.你的项目（非常重要） 

​   ：从应用场景——架构设计——关键的点——用到的基础——storm相关——kafka的原理——redis原理 

    7. Linux的常用命令、git的简单命令（了解） 







深度优先搜索树，DFS

二叉搜索树 中序遍历

一个数组里的数字 求全排列。







- 请你回答一下静态函数和虚函数的区别
- 请你说一说vector和list的区别，应用，越详细越好
- 右值引用和左值引用的区别：
- 请你回答一下如何判断内存泄漏？
- 请你回答一下fork和vfork的区别？
- 请你说一说有了进程，为什么还要有线程？
- 请你介绍一下数据库的ACID特性
- 请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？
- 请你说一说HTTP和HTTPS的不同





redis数据类型，一致性hash，热点数据，数据倾斜怎么解决。



spring的和兴

dubbo和zoomkeeper的区别







mysql：索引

事物 

事物的四个特性和隔离级别



项目：精要一些。系统，学到了什么。



JMM:



类加载



各种锁优化



GC垃圾手机方式



垃圾区域划分



说一下Hashmap

concurrentHashmap分段锁

说一下集合。

IO流



设计模式：单例，工厂，动态代理

设计原则：开闭，依赖倒转。



操作系统：死锁（）预防死锁，线程状态，以及线程通信方式（管道，内存，队列）。



计算机网络。

http和https  ssl交互的, osi七层，四层 

TCP可靠链接 UDP 不可靠链接，区别  三次握手 四次握手 应用场景。TCP和UDP传输数据量。

DNS:



数据结构：排序各种算法和复杂度。

快排N（N2） 堆排序 数据量很大的问题。

数据结构本身。区别。树，链表。





缓存：redis数据类型，以及 实现原理。（set） 高可用，一致性哈希（redis集群保证有效性）。主从复制（应对其中一台）。



Spring 一般 AOP，IOC。SpringMVC的流程。SpringBoot。





- 垃圾

  









- 程序计数器：记住下一条JVM指令的执行地址，线程私有的，就是属于自己的线程。线程切换不影响。不会存在内存溢出。

- 每个线程运行时所需要的内存，称为虚拟机栈

- 栈：线程运行需要的内存空间

- 栈针：每个方法运行时需要的内存，栈针组成了栈。活动栈针就是当前的调用的栈针

- 垃圾回收是否涉及栈内存？

  > 不涉及，因为栈针内存每次调用结束就弹出栈了

- 栈内存越大越好吗？

  > 栈内存越大，线程数越少。物理内存有限，栈内存越大，可以分配的线程就越少。

- 方法内的局部变量是否是线程安全的

  > 因为局部变量时线程私有的，所以不会受其他线程干扰。但是static修饰的共享变量就不是线程安全的。
  >
  > - 方法内的局部变量 作用范围 没有逃离方法的作用范围，那就是线程安全的。反之，传入的或者返回的都不线程安全。
  >
  > - 如果局部变量引用了对象，并且逃离方法的作用范围，需要考虑线程安全的问题。

- 栈内存溢出

  > 栈针过多，导致栈内存溢出
  >
  > 栈针过大导致栈内存溢出
  >
  > -Xss 参数。 -Xss256k
  >
  > 方法诊断
  >
  > TOP之后 jstack

- 本地方法栈：

  > 不是由java代码编写的代码。native 关键字修饰，一般是C或者C++，java通过本地方法实现系统调用。

- Heap堆：

  > 通过new关键字，创建的对象都会使用堆内存。
  >
  > 特点：线程共享的，堆中对象都需要考虑线程安全的问题。有垃圾回收机制。

- 堆溢出

  >OutOfMemoryError。 java heap space
  >
  >参数名  -Xmx8m -> 把堆空间改成8M
  >
  >jps -> map heap -> 
  >
  >jconsole
  >
  >java VisualVM

- 方法区：java虚拟机共享的线程，存储了跟类的结构相关的信息。方法啊，构造器，成员方法

  > 方法区/元空间溢出：
  >
  > 1.8      -XX:MaxMetaspaceSize=8m
  >
  > 1.6  - XX:MaxPermSize=8m
  >
  > 方法区1.6在永久代，1.8在元空间（本地内存）
  >
  > 1.6串池在永久代（full GC才会收，导致回收效率不高，因为又经常用，回收率不高，肯定会影响。），1.7，1.8就到了堆中，miner GC就会回收。
  >
  > 方法区里有运行时常量池
  >
  > 二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）

- 运行时常量池：

  > 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等信息。
  >
  > 运行时常量池。常量池是.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。

- 串池

  > 运行的时候从常量池 放到串池。
  >
  > 1. 常量池中的字符串仅是符号，第一次用到时才变为对象
  > 2. 利用串池的机制，来避免重复创建字符串对象
  > 3. 字符串标量拼接的原理是StringBuilder(1.8)
  > 4. 字符串常量拼接的原理是编译器优化
  > 5. 可以使用intern方法，主动将串池中还没有的字符串对象放入串池
  >    - 1.8将这个字符串对象尝试放入串池，如果有则不会放入，如果没有就放入，然后返回
  >    - 1.6将这个字符串对象，尝试放入串池，如果有则不会放入，如果没有，就会复制一份放入串池，然后把串池中的对象返回。



- 垃圾回收

  - StringTable 垃圾回收

- 直接内存

  >常见于NIO操作时，用于数据缓冲区
  >
  >分配回收成本较高，但是读写性能高。
  >
  >不受JVM内存回收管理















树的右视图

12345 123找出两个递增数组分割点。

兔子繁衍问题 5个月

1000个硬币里有10个金硬币，求选n个能选到金硬币的个数。















